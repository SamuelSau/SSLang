#include "llvmGen/LLVMCodeGen.h"
#include "llvmGen/LLVMUtility.h"
#include "symbolTable/SymbolTable.h"

SymbolTable symbolTable;

 LLVMCodeGen::LLVMCodeGen()
     : module(new llvm::Module("MyModule", context)), builder(context) {
     //Initialize module and IR builder
 }

 LLVMCodeGen::~LLVMCodeGen() {
     delete module;
 }

 llvm::Module* LLVMCodeGen::getModule() const {
	 return module;
 }

 llvm::Value* LLVMCodeGen::evaluateExpression(Expression* expr) {
	 // This function should visit the expression and return an llvm::Value* representing its value.
	 // This is a placeholder for actual expression evaluation logic.
	 expr->accept(this);
	 std::cout << "We are in evaluateExpression\n";
	 std::cout << "Last value: " << lastValue << "\n";
	 // Assuming 'lastValue' holds the result of the last visited expression.
	 // Last value generated by visiting an expression
	 llvm::Value* result = lastValue;
	 lastValue = nullptr;
	 return result;
 }

 void LLVMCodeGen::visit(const Program* program) {
     for (const auto& decl : program->declarations) {
         decl->accept(this);
     }
     for (const auto& func : program->functions) {
		 func->accept(this);
	 }
     
     for (const auto& stmt : program->statements) {
		 stmt->accept(this);
	 }

     for (const auto& expr : program->expressions) {
        expr->accept(this);
     }
     
 }

 void LLVMCodeGen::visit(const IntDeclaration* decl) {
	 llvm::Constant* initVal = llvm::ConstantInt::get(context, llvm::APInt(32, std::stoi(decl->number), true));
	 
	 if (currentFunction) { //need testing
		 // Handle as local variable
		 llvm::IRBuilder<> tmpBuilder(&currentFunction->getEntryBlock(), currentFunction->getEntryBlock().begin());
		 llvm::AllocaInst* alloca = tmpBuilder.CreateAlloca(llvm::Type::getInt32Ty(context), 0, decl->name);
		 builder.CreateStore(initVal, alloca);

		 // Remember the variable for later use within the function
		 currentLocals[decl->name] = alloca;

	 }
	 else {
		 
		 // Create a global variable in the module.
		 llvm::GlobalVariable* gVar = new llvm::GlobalVariable(
			 *module,
			 llvm::Type::getInt32Ty(context), // Assuming 32-bit integers
			 false,                           // isConstant: false since it's a variable
			 llvm::GlobalValue::ExternalLinkage,
			 initVal,                         // Initializer
			 decl->name                       // Variable name
		 );

		 // Optionally, set alignment
		 gVar->setAlignment(llvm::MaybeAlign(4));
		 globals[decl->name] = gVar;
	 }
 }

 void LLVMCodeGen::visit(const FloatDeclaration* decl) {
	 
	 llvm::ConstantFP* initVal = llvm::ConstantFP::get(context, llvm::APFloat(std::stof(decl->number)));

	 if (currentFunction) {
		 // Handle as local variable
		 llvm::IRBuilder<> tmpBuilder(&currentFunction->getEntryBlock(), currentFunction->getEntryBlock().begin());
		 llvm::AllocaInst* alloca = tmpBuilder.CreateAlloca(llvm::Type::getFloatTy(context), nullptr, decl->name);
		 builder.CreateStore(initVal, alloca);

		 // Remember the variable for later use within the function
		 currentLocals[decl->name] = alloca;

	 }
	 else {
		 // Handle as global variable
		 llvm::GlobalVariable* gVar = new llvm::GlobalVariable(
			 *module,
			 llvm::Type::getFloatTy(context), // Assuming 32-bit integers
			 false,                           // isConstant: false since it's a variable
			 llvm::GlobalValue::ExternalLinkage,
			 initVal,                         // Initializer
			 decl->name                       // Variable name
		 );

		 // Optionally, set alignment
		 gVar->setAlignment(llvm::MaybeAlign(4));

		 globals[decl->name] = gVar;
		 
	 }

 }

 void LLVMCodeGen::visit(const StringDeclaration* decl) {
	 if (currentFunction) {
		 auto& context = builder.getContext();
		 llvm::Type* charType = llvm::Type::getInt8Ty(context);
		 auto strValue = builder.CreateGlobalStringPtr(decl->value, "globalStr");
		 llvm::ArrayType* strType = llvm::ArrayType::get(charType, decl->value.size() + 1); // +1 for null terminator
		 auto alloca = builder.CreateAlloca(strType, nullptr, decl->name);
		 builder.CreateStore(strValue, alloca);
		 
		 currentLocals[decl->name] = alloca;
	 }

	 else {
		 // Global string variable case
		 auto& context = builder.getContext();
		 auto strValue = llvm::ConstantDataArray::getString(context, decl->value, true); // true for adding null terminator
		 auto strGlobalVar = new llvm::GlobalVariable(*module, strValue->getType(), true, llvm::GlobalValue::PrivateLinkage, strValue, decl->name + ".globalStr");

		 // Create a constant pointer to the first element of the string
		 auto zero = llvm::ConstantInt::get(llvm::Type::getInt64Ty(context), 0);
		 std::vector<llvm::Constant*> indices{ zero, zero };
		 auto strPtr = llvm::ConstantExpr::getGetElementPtr(strValue->getType(), strGlobalVar, indices);

		 // Store the pointer in a global variable
		 llvm::GlobalVariable* gVar = new llvm::GlobalVariable(*module, strPtr->getType(), false, llvm::GlobalValue::ExternalLinkage, strPtr, decl->name);

		 // Optionally, set alignment for the global variable
		 gVar->setAlignment(llvm::MaybeAlign(1)); // Alignment for characters is typically 1

		 // Save the global variable in globals for later reference
		 globals[decl->name] = gVar;
	 }
 }

 void LLVMCodeGen::visit(const BoolDeclaration* decl) {
	 llvm::Constant* initVal = llvm::ConstantInt::get(llvm::Type::getInt1Ty(context), decl->value == "true" ? 1 : 0);

	 if (currentFunction) {
		 // Handle as a local variable within a function
		 llvm::IRBuilder<> tmpBuilder(&currentFunction->getEntryBlock(), currentFunction->getEntryBlock().begin());
		 llvm::AllocaInst* alloca = tmpBuilder.CreateAlloca(llvm::Type::getInt1Ty(context), nullptr, decl->name);
		 builder.CreateStore(initVal, alloca);

		 // Remember the variable for later use within the function
		 currentLocals[decl->name] = alloca;
	 }
	 else {
		 // Handle as a global variable
		 llvm::GlobalVariable* gVar = new llvm::GlobalVariable(
			 *module,
			 llvm::Type::getInt1Ty(context), // Type for boolean
			 false,                          // isConstant: false since it's a variable
			 llvm::GlobalValue::ExternalLinkage,
			 initVal,                        // Initializer
			 decl->name                      // Variable name
		 );

		 // Optionally, set alignment
		 gVar->setAlignment(llvm::MaybeAlign(1)); // Alignment for boolean is typically 1

		 // Save the global variable in globals for later reference
		 globals[decl->name] = gVar;
	 }
 }


 void LLVMCodeGen::visit(const ReturnStatement* stmt) {
	 // First, evaluate the expression to get its value
	 llvm::Value* returnValue = evaluateExpression(stmt->expression.get());

	 if (!returnValue) {
		 std::cerr << "Error evaluating return expression." << std::endl;
		 return;
	 }

	 builder.CreateRet(returnValue);
 }

 void LLVMCodeGen::visit(const LoopStatement* stmt) {
	 //Generate LLVM IR for a loop statement.
 }

 void LLVMCodeGen::visit(const ForLoopStatement* stmt) {
	 //Generate LLVM IR for a for loop statement.
 }

 void LLVMCodeGen::visit(const WhileLoopStatement* stmt) {
	 //Generate LLVM IR for a while loop statement.
 }

 void LLVMCodeGen::visit(const IfStatement* stmt) {
	 auto& context = builder.getContext();
	 auto* function = builder.GetInsertBlock()->getParent();

	 // Create blocks for the then, else (optional), and merge parts of the if statement
	 llvm::BasicBlock* thenBB = llvm::BasicBlock::Create(context, "then", function);
	 llvm::BasicBlock* elseBB = llvm::BasicBlock::Create(context, "else");
	 llvm::BasicBlock* mergeBB = llvm::BasicBlock::Create(context, "ifcont", function);

	 // Assuming 'condition' is an Expression that can be evaluated to a value
	 llvm::Value* condValue = evaluateExpression(stmt->condition.get());; // Evaluate the condition expression
     
	 // Create a conditional branch on the condition value
     builder.CreateCondBr(condValue, thenBB, elseBB);

	 // Populate the 'then' block
	 builder.SetInsertPoint(thenBB);
	 // Visit/translate the body of the 'then' part
	 stmt->body->accept(this);
	 builder.CreateBr(mergeBB); // Jump to the merge block after the 'then' part

	 // Add the 'else' block to the function and populate it if there is an else part
	 //function->getBasicBlockList().push_back(elseBB);
	 builder.SetInsertPoint(elseBB);
	 // If there's an else statement, visit it. Else, skip. (right now its not implemented)
	 //if (stmt->elseStmt) {
		// stmt->elseStmt->accept(this);
	 //}
	 builder.CreateBr(mergeBB); // Jump to the merge block after the 'else' part

	 // Add the merge block to the function
	 //function->getBasicBlockList().push_back(mergeBB);
	 builder.SetInsertPoint(mergeBB);
 }


 void LLVMCodeGen::visit(const ElseStatement* stmt) {
	 //Generate LLVM IR for an else statement.
	 assert(false && "ElseStatement should be visited as part of IfStatement handling.");
 }

 void LLVMCodeGen::visit(const AssignmentStatement* stmt) {
	 //Generate LLVM IR for an assignment statement.
 }

 void LLVMCodeGen::visit(const PrintStatement* stmt) {
	 //Generate LLVM IR for a print statement, for example log("Print statement");
 }

 void LLVMCodeGen::visit(const BlockStatement* stmt) {
	 //Generate LLVM IR for a block statement.
 }

 void LLVMCodeGen::visit(const ExpressionStatement* stmt) {
	 //Generate LLVM IR for an expression statement.

 }

 void LLVMCodeGen::visit(const BinaryExpression* expr) {
	 //Generate LLVM IR for a binary expression.
     // Evaluate the left and right subexpressions
	 llvm::Value* left = evaluateExpression(expr->left.get());
	 llvm::Value* right = evaluateExpression(expr->right.get());

	 if (!left && !right) {
		 std::cerr << "Error evaluating binary expression for left and right" << std::endl;
		 lastValue = nullptr;
		 return;
	 }

	 std::cout << "Binary expression: " << expr->op << "\n";

	 // Example for addition; actual operation depends on `expr->op`
	 if (expr->op == "+") {
		 // Assuming `left` and `right` are integers
		 lastValue = builder.CreateAdd(left, right, "addtmp");
	 }
	 else if (expr->op == "-") {
		lastValue = builder.CreateSub(left, right, "subtmp");
	 }
	 else if (expr->op == "*") {
		 lastValue = builder.CreateMul(left, right, "multmp");
	 }
	 else if (expr->op == "/") {
		 lastValue = builder.CreateSDiv(left, right, "divtmp");
	 }
	 if (expr->op == "<") {
		 lastValue = builder.CreateICmpSLT(left, right, "cmptmp");
	 }
	 else if (expr->op == ">") {
		 lastValue = builder.CreateICmpSGT(left, right, "cmptmp");
	 }
	 else if (expr->op == "<=") {
		 lastValue = builder.CreateICmpSLE(left, right, "cmptmp");
	 }
	 else if (expr->op == ">=") {
		 lastValue = builder.CreateICmpSGE(left, right, "cmptmp");
	 }
	 else if (expr->op == "equals") {
		 lastValue = builder.CreateICmpEQ(left, right, "cmptmp");
	 }
	 else if (expr->op == "notEquals") {
		 lastValue = builder.CreateICmpNE(left, right, "cmptmp");
	 }
	 else {
		 std::cerr << "Unsupported binary operation: " << expr->op << std::endl;
		 lastValue = nullptr;
	 }
 }

 void LLVMCodeGen::visit(const UnaryExpression* expr) {
	 //Generate LLVM IR for a unary expression.

	 llvm::Value* operand = evaluateExpression(expr->expr.get());
	 if (!operand) {
		 std::cerr << "Null operand in unary expression." << std::endl;
		 return;
	 }

	 if (expr->op == "-") {
		 // Assuming the operand is an integer
		 lastValue = builder.CreateNeg(operand, "negtmp");
	 }
	 else if (expr->op == "not") {
		 // Assuming the operand is a boolean
		 lastValue = builder.CreateNot(operand, "nottmp");
	 }
	 else {
		 std::cerr << "Unsupported unary operation: " << expr->op << std::endl;
		 lastValue = nullptr;
	 }
 }

 void LLVMCodeGen::visit(const PrimaryExpression* expr) {
	 //Generate LLVM IR for a primary expression.
	 // Handle integer literals
	 static const std::regex intRegex("^[-+]?[0-9]+$");
	 // Handle floating-point literals
	 static const std::regex floatRegex("^[-+]?[0-9]*\\.[0-9]+$");
	 // Handle string literals
	 static const std::regex stringRegex("^\".*\"$");

	 if (std::regex_match(expr->name, intRegex)) {
		 int value = std::stoi(expr->name);
		 lastValue = llvm::ConstantInt::get(context, llvm::APInt(32, value, true));
	 }
	 else if (std::regex_match(expr->name, floatRegex)) {
		 float value = std::stof(expr->name);
		 lastValue = llvm::ConstantFP::get(context, llvm::APFloat(value));
	 }
	 else if (expr->name == "true" || expr->name == "false") {
		 bool value = (expr->name == "true");
		 lastValue = llvm::ConstantInt::get(context, llvm::APInt(1, value, true));
	 }
	 else if (std::regex_match(expr->name, stringRegex)) {
		 // Strings are a bit more complex due to their global nature
		 lastValue = builder.CreateGlobalStringPtr(expr->name.substr(1, expr->name.length() - 2), expr->name + ".str");
	 }
	 else {
		 // Assume it's a variable name. Look up its value in `currentLocals`.
		 auto it = currentLocals.find(expr->name);
		 if (it != currentLocals.end()) {
			 auto allocaInst = llvm::dyn_cast<llvm::AllocaInst>(it->second);
			 if (!allocaInst) {
				 std::cerr << "Expected a variable allocation for: " << expr->name << std::endl;
				 lastValue = nullptr;
				 return;
			 }
			 // Load the variable's value
			 lastValue = builder.CreateLoad(allocaInst->getAllocatedType(), allocaInst, expr->name);
		 }
		 else {
			 std::cerr << "Variable not found: " << expr->name << std::endl;
			 lastValue = nullptr;
		 }
	 }
 }

 void LLVMCodeGen::visit(const AssignmentExpression* expr) {
	 //Generate LLVM IR for an assignment expression.
 }

 void LLVMCodeGen::visit(const FunctionDefinition* funcDef) {
	 std::cout << funcDef->toString() << std::endl;
	 std::vector<llvm::Type*> paramTypes;
	 for (const auto& param : funcDef->parameters) {
		 std::cout << "Param type: " << param.type << "\n";
		 llvm::Type* type = nullptr;
		 if (param.type == "int") {
			 std::cout << "parameter type is int" << std::endl;
			 type = llvm::Type::getInt32Ty(context);
		 }
		 else if (param.type == "float") {
			 type = llvm::Type::getFloatTy(context);
		 }
		 else if (param.type == "bool") {
			 type = llvm::Type::getInt1Ty(context);
		 }
		 //else if (param.type == "string") { // not sure if this is correct
			// type = llvm::Type::getInt8PtrTy(context);
		 //}
		 else if (param.type == "void") {
			 type = llvm::Type::getVoidTy(context);
		 }
		 // Add more type mappings as necessary
		 if (type) {
			 paramTypes.push_back(type);
		 }
		 else {
			 std::cerr << "Unsupported parameter type: " << param.type << std::endl;
			 return; // Skip unsupported types
		 }
	 }

	 llvm::Type* returnType = nullptr;
	 if (funcDef->returnType == "int") {
		 returnType = llvm::Type::getInt32Ty(context);
	 }
	 else if (funcDef->returnType == "float") {
		 returnType = llvm::Type::getFloatTy(context);
	 }
	 else if (funcDef->returnType == "bool") {
		 returnType = llvm::Type::getInt1Ty(context);
	 }
	 //else if (funcDef->returnType == "string") { // not sure if this is correct
		// returnType = llvm::Type::getInt8PtrTy(context);
	 //}
	 else if (funcDef->returnType == "void") {
		 returnType = llvm::Type::getVoidTy(context);
	 }

	 llvm::FunctionType* functionType = llvm::FunctionType::get(returnType, paramTypes, false);
	 llvm::Function* function = llvm::Function::Create(functionType, llvm::Function::ExternalLinkage, funcDef->name, module);

	 // Create a new basic block to start insertion into.
	 llvm::BasicBlock* block = llvm::BasicBlock::Create(context, "entry", function);
	 builder.SetInsertPoint(block);

	 currentFunction = function; // Track the current function

	 // Record the function arguments in the NamedValues map.
	 unsigned idx = 0;
	 for (auto& arg : function->args()) {

		 arg.setName(funcDef->parameters[idx].name);
		 // Create an alloca for this variable.
		 llvm::AllocaInst* alloca = llvm_util::createEntryBlockAlloca(function, std::string(arg.getName()), arg.getType());

		 // Store the initial value into the alloca.
		 builder.CreateStore(&arg, alloca);

		 // Add arguments to variable currentLocals
		 currentLocals[std::string(arg.getName())] = alloca;

		 idx++;
	 }

	 // Visit each statement in the function body to generate their IR
	 for (const auto& stmt : funcDef->body) {
		 stmt->accept(this);
	 }

	 // Add a return statement for void functions if not present
	 if (returnType == llvm::Type::getVoidTy(context) && !block->getTerminator()) {
		 builder.CreateRetVoid();
	 }

	 currentFunction = nullptr; // Clear the current function

	 // Optimize the function.
	 // (You may add optimization passes here)

	 // Reset the builder's insert point
	 builder.ClearInsertionPoint();

	 // Verify the generated code, checking for consistency.
	 llvm::verifyFunction(*function, &llvm::errs());
 }

 void LLVMCodeGen::visit(const FunctionCall* call) {
	 //Generate LLVM IR for a function call.
 }


